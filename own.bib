%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Paolo G. Giarrusso at 2018-12-01 01:31:49 +0100 


%% Saved with string encoding Unicode (UTF-8) 


@comment{Argument to noopsort is used for sorting but not shown. See https://tex.stackexchange.com/a/31411/1340}
@preamble{" \newcommand{\noopsort}[1]{} "}


@string{acm = {ACM}}

@string{acmaddr = {}}

@string{ldta = {Proceedings of Workshop on Language Descriptions, Tools and Applications (LDTA)}}

@string{pldi = {Programming Language Design and Implementation}}


@inproceedings{Cai2016system,
	Author = {Cai, Yufei and Giarrusso, Paolo G. and Ostermann, Klaus},
	Booktitle = {Proceedings of the 43rd {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
	Date-Added = {2017-08-11 20:52:17 +0000},
	Date-Modified = {2017-08-11 20:52:17 +0000},
	File = {Cai et al - 2016 - System F-omega with Equirecursive Types for Datatype-generic Programming.pdf:/Users/pgiarrusso/Library/Application Support/Zotero/Profiles/0lm7uqnz.default/zotero/storage/U7VFZDQP/Cai et al - 2016 - System F-omega with Equirecursive Types for Datatype-generic Programming.pdf:application/pdf;Snapshot:/Users/pgiarrusso/Library/Application Support/Zotero/Profiles/0lm7uqnz.default/zotero/storage/XEHQ35DZ/citation.html:text/html},
	Keywords = {Datatype-generic programming,equirecursive types,functors},
	Publisher = {{ACM}},
	Timestamp = {2017-08-11T20:51:38Z},
	Title = {System {{F}}-Omega with {{Equirecursive Types}} for {{Datatype}}-Generic {{Programming}}},
	Urldate = {2017-01-18},
	Volume = {2016},
	Year = {2016}}

@inproceedings{Giarrusso2013gadt,
	Acmid = {2489842},
	Address = {New York, NY, USA},
	Articleno = {5},
	Author = {Giarrusso, Paolo G.},
	Booktitle = {Proceedings of the 4th Workshop on Scala},
	Date-Added = {2017-07-25 16:07:54 +0000},
	Date-Modified = {2017-07-25 16:08:01 +0000},
	Doi = {10.1145/2489837.2489842},
	Isbn = {978-1-4503-2064-1},
	Keywords = {DSL embedding, Scala, lambda-calculus, lightweight modular staging, soundness, type-safety},
	Location = {Montpellier, France},
	Numpages = {4},
	Pages = {5:1--5:4},
	Publisher = {ACM},
	Series = {SCALA '13},
	Title = {Open {GADTs} and Declaration-site Variance: A Problem Statement},
	Url = {http://doi.acm.org/10.1145/2489837.2489842},
	Year = {2013},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2489837.2489842},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2489837.2489842}}

@article{siegmund2013scalable,
	Author = {Siegmund, Norbert and Rosenm{\"u}ller, Marko and K{\"a}stner, Christian and Giarrusso, Paolo G. and Apel, Sven and Kolesnikov, Sergiy S.},
	Date-Added = {2017-07-25 15:53:55 +0000},
	Date-Modified = {2017-07-25 15:54:30 +0000},
	Journal = {Information and Software Technology},
	Number = {3},
	Pages = {491--507},
	Publisher = {Elsevier},
	Title = {Scalable prediction of non-functional properties in software product lines: Footprint and memory consumption},
	Volume = {55},
	Year = {2013}}

@inproceedings{Giarrusso2019Incremental,
  title = {Incremental {$\lambda$}-Calculus in Cache-Transfer Style},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Giarrusso, Paolo G. and {R{\'e}gis-Gianas}, Yann and Schuster, Philipp},
  editor = {Caires, Lu{\'i}s},
  year = {2019},
  pages = {553--580},
  publisher = {{Springer International Publishing}},
  abstract = {Incremental computation requires propagating changes and reusing intermediate results of base computations. Derivatives, as produced by static differentiation [7], propagate changes but do not reuse intermediate results, leading to wasteful recomputation. As a solution, we introduce conversion to Cache-Transfer-Style, an additional program transformations producing purely incremental functional programs that create and maintain nested tuples of intermediate results. To prove CTS conversion correct, we extend the correctness proof of static differentiation from STLC to untyped {$\mathsl{\lambda}\lambda\backslash$}lambda -calculus via step-indexed logical relations, and prove sound the additional transformation via simulation theorems.To show ILC-based languages can improve performance relative to from-scratch recomputation, and that CTS conversion can extend its applicability, we perform an initial performance case study. We provide derivatives of primitives for operations on collections and incrementalize selected example programs using those primitives, confirming expected asymptotic speedups.},
  isbn = {978-3-030-17184-1},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@phdthesis{CaiPhD,
	Author = {Yufei Cai},
	Date-Added = {2017-05-10 14:27:52 +0000},
	Date-Modified = {2017-05-10 14:30:31 +0000},
	Note = {In preparation},
	School = {University of T{\"u}bingen},
	Year = {2017}}

@phdthesis{GiarrussoPhD2018,
	Author = {Paolo G. Giarrusso},
	Date-Added = {2017-05-10 14:27:52 +0000},
	Date-Modified = {2018-01-14 22:54:15 +0000},
	Note = {Defended. Draft available at \url{http://inc-lc.github.io/}},
	School = {University of T{\"u}bingen},
	Title = {Optimizing and Incrementalizing Higher-order Collection Queries by {AST} Transformation},
	Year = {2018}}

@inproceedings{CaiEtAl2014ILC,
	Acmid = {2594304},
	Address = {New York, NY, USA},
	Author = {Cai, Yufei and Giarrusso, Paolo G. and Rendel, Tillmann and Ostermann, Klaus},
	Booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	Date-Added = {2017-06-10 16:37:36 +0000},
	Date-Modified = {2017-06-10 16:37:36 +0000},
	Doi = {10.1145/2594291.2594304},
	Isbn = {978-1-4503-2784-8},
	Keywords = {Agda, first-class functions, formalization, incremental computation, performance},
	Location = {Edinburgh, United Kingdom},
	Numpages = {11},
	Pages = {145--155},
	Publisher = {ACM},
	Series = {PLDI '14},
	Title = {A theory of changes for higher-order languages --- {Incrementalizing} {$\lambda$}-calculi by static differentiation},
	Url = {http://doi.acm.org/10.1145/2594291.2594304},
	Year = {2014},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2594291.2594304},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2594291.2594304}}

@inproceedings{ErdwegGR12,
	Abstract = {In language-oriented programming and modeling, software developers are largely concerned with the definition of domain-specific languages (DSLs) and their composition. While various implementation techniques and frameworks exist for defining DSLs, language composition has not obtained enough attention and is not well-enough understood. In particular, there is a lack of precise terminology for describing observations about language composition in theory and in existing language-development systems. To clarify the issue, we specify five forms of language composition: language extension, language restriction, language unification, self-extension, and extension composition. We illustrate this classification by various examples and apply it to discuss the performance of different language-development systems with respect to language composition. We hope that the terminology provided by our classification will enable more precise communication on language composition.},
	Acmid = {2427055},
	Address = {New York, NY, USA},
	Articleno = {7},
	Author = {Erdweg, Sebastian and Giarrusso, Paolo G. and Rendel, Tillmann},
	Booktitle = ldta,
	Date-Added = {2013-04-28 23:24:03 +0000},
	Date-Modified = {2013-04-28 23:28:30 +0000},
	Doi = {10.1145/2427048.2427055},
	Isbn = {978-1-4503-1536-4},
	Keywords = {domain-specific language, language composition, language extension, language unification, self-extension},
	Location = {Tallinn, Estonia},
	Numpages = {8},
	Pages = {7:1--7:8},
	Pdf = {http://www.informatik.uni-marburg.de/~seba/publications/languagecomposition.pdf},
	Publisher = {ACM},
	Read = {1},
	Series = {LDTA '12},
	Title = {Language composition untangled},
	Url = {http://doi.acm.org/10.1145/2427048.2427055},
	Year = {2012},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/2427048.2427055},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2427048.2427055}}

@inproceedings{GiarrussoAOSD13,
	Author = {Giarrusso, Paolo G. and Ostermann, Klaus and Eichberg, Michael and Mitschke, Ralf and Rendel, Tillmann and K{\"{a}}stner, Christian},
	Booktitle = {AOSD},
	Keywords = {deep embedding, modularity, optimization, query languages},
	Location = {Fukuoka, Japan},
	Noacmid = {2451438},
	Noaddress = {New York, NY, USA},
	Nodoi = {10.1145/2451436.2451438},
	Noisbn = {978-1-4503-1766-5},
	Noseries = {AOSD '13},
	Nourl = {http://doi.acm.org/10.1145/2451436.2451438},
	Numpages = {12},
	Pages = {1--12},
	Publisher = {ACM},
	Title = {Reify your collection queries for modularity and speed!},
	Year = {2013}}

@inproceedings{KPO:VaMoS11,
	Abstract = {
The C preprocessor is commonly used to implement
variability. Given a feature selection, code fragments
can be excluded from compilation with \#ifdef and similar
directives. However, the token-based nature of the C preprocessor
makes variability implementation difficult and errorprone.
Additionally, variability mechanisms are intertwined
with macro definitions, macro expansion, and file inclusion.
To determine whether a code fragment is compiled, the entire
file must be preprocessed. We present a partial preprocessor
that preprocesses file inclusion and macro expansion, but
retains variability information for further analysis.We describe
the mechanisms of the partial preprocessor, provide a full
implementation, and present some initial experimental results.
The partial preprocessor is part of a larger endeavor in
the TypeChef project to check variability implementations
(syntactic correctness, type correctness) in C projects such as
the Linux kernel.			
},
	Address = ACMAddr,
	Author = {Christian K{\"a}stner and Paolo G. Giarrusso and Klaus Ostermann},
	Booktitle = {Proceedings of the Fifth International Workshop on Variability Modelling of Software-intensive Systems (VaMoS)},
	Isbn = {978-1-4503-0570-9},
	Location = {Namur, Belgium},
	Month = jan,
	Nonote = {Acceptance rate: 55\,\% (21/38)},
	Pages = {137--140},
	Publisher = ACM,
	Title = {Partial Preprocessing {C} Code for Variability Analysis},
	Url = {http://www.informatik.uni-marburg.de/~kaestner/vamos11.pdf},
	Year = 2011,
	Bdsk-Url-1 = {http://www.informatik.uni-marburg.de/~kaestner/vamos11.pdf}}

@inproceedings{OGKR:ECOOP11,
	Abstract = {
What is modularity? Which kind of modularity should developers strive for?
Despite decades of research on modularity, these basic questions have
no definite answer. We submit that the common understanding of
modularity, and in particular its notion of information hiding, is 
deeply rooted in classical logic.
We analyze how classical modularity, based on classical logic, fails to 
address the needs of developers of large software systems, and
encourage researchers to explore alternative visions of
modularity, based on nonclassical logics, and henceforth called
nonclassical
modularity.	
	},
	Author = {Klaus Ostermann and Paolo G. Giarrusso and Christian K{\"a}stner and Tillmann Rendel},
	Booktitle = {Proceedings of the 25th European Conference on Object-Oriented Programming (ECOOP)},
	Ereader = {http://www.informatik.uni-marburg.de/~kaestner/ecoop11_ereader.pdf},
	Nonote = {Acceptance rate: 24\,\%; accepted for publication},
	Publisher = Springer,
	Selected = 1,
	Title = {Revisiting Information Hiding: Reflections on Classical and Nonclassical Modularity},
	Url = {http://www.informatik.uni-marburg.de/~kaestner/ecoop11.pdf},
	Year = 2011,
	Bdsk-Url-1 = {http://www.informatik.uni-marburg.de/~kaestner/ecoop11.pdf}}

@inproceedings{SRKGAK:SPLC11,
	Abstract = {
A software product line (SPL) is a family of related software products, from which users can derive a product that fulfills their needs.
Often, users expect a product to have specific non-functional properties, for example, to not exceed a footprint limit or to respond in a given time frame. Unfortunately, it is usually not feasible to generate and measure non-functional properties for each possible product of an SPL in isolation, because an SPL can contain millions of products. Hence, we propose an approach to \emph{estimate} each product's non-functional properties in advance, based on the product's configuration. To this end, we approximate non-functional properties \emph{per features} and per feature interaction. We generate and measure a small set of products and approximated non-functional properties by comparing the measurements. Our approach is implementation independent and language independent. We present three different approaches with different trade-offs regarding accuracy and required number of measurements. With nine case studies, we demonstrate that our approach can predict non-functional properties with an accuracy of 2\%.	
	},
	Address = IEEEAddr,
	Author = {Norbert Siegmund and Marko Rosenm{\"u}ller and Christian K{\"a}stner and Paolo G. Giarrusso and Sven Apel and Sergiy Kolesnikov},
	Booktitle = {Proceedings of the 15th International Software Product Line Conference (SPLC)},
	Location = {Munich},
	Month = aug,
	Note = {to appear; submitted 27 Feb 2010, accepted 21 Apr 2011},
	Publisher = IEEE,
	Title = {Scalable Prediction of Non-functional Properties in Software Product Lines},
	Url = {http://www.informatik.uni-marburg.de/~kaestner/SPLC11_nfp.pdf},
	Year = 2011,
	Bdsk-Url-1 = {http://www.informatik.uni-marburg.de/~kaestner/SPLC11_nfp.pdf}}

@inproceedings{KGREOB:OOPSLA11,
	Abstract = {
In many projects, lexical preprocessors are used to manage
different variants of the project (using conditional compilation)
and to define compile-time code transformations (using
macros). Unfortunately, while being a simply way to implement
variability, conditional compilation and lexical macros
hinder automatic analysis, even though such analysis would
be urgently needed to combat variability-induced complexity.
To analyze code with its variability, we need to parse
it without preprocessing it. However, current parsing solutions
use heuristics, support only a subset of the language, or
suffer from exponential explosion. As part of the TypeChef
project, we contribute a novel variability-aware parser that
can parse unpreprocessed code without heuristics in practicable
time. Beyond the obvious task of detecting syntax errors,
our parser paves the road for further analysis, such as
variability-aware type checking. We implement variabilityaware
parsers for Java and GNU C and demonstrate practicability
by parsing the product line MobileMedia and the
entire X86 architecture of the Linux kernel with 6065 variable
features.
	},
	Address = ACMAddr,
	Author = {Christian K{\"a}stner and Paolo G. Giarrusso and Tillmann Rendel and Sebastian Erdweg and Klaus Ostermann and Thorsten Berger},
	Booktitle = {Proceedings of the 26th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)},
	Location = {Portland, OR},
	Month = oct,
	Nonote = {Acceptance rate: 37\,\% (61/166); submitted 8 Apr 2011, accepted 13 Jun 2011},
	Pdf = {http://www.informatik.uni-marburg.de/~kaestner/oopsla11_typechef_submitted.pdf},
	Publisher = ACM,
	Selected = 1,
	Title = {Variability-Aware Parsing in the Presence of Lexical Macros and Conditional Compilation},
	Year = 2011}

@inproceedings{GiarrussoEtAl2012Reify,
	Author = {Paolo G. Giarrusso and Klaus Ostermann and Michael Eichberg and Tillmann Rendel and Christian K{\"a}stner},
	Booktitle = {SPLASH'12 Conference Companion---Poster Abstracts},
	Title = {Reifying and Optimizing Collection Queries for Modularity},
	Year = 2012}

@inproceedings{Giarrusso2012Reify,
	Author = {Paolo G. Giarrusso},
	Booktitle = {SPLASH'12 Doctoral Symposium},
	Title = {Reifying and Optimizing Collection Queries for Modularity},
	Year = 2012}

@article{GiarrussoEtAl2012ReifyTR,
	Author = {Paolo G. Giarrusso and Klaus Ostermann and Michael Eichberg and Ralf Mitschke and Tillmann Rendel and Christian K{\"a}stner},
	Bibsource = {DBLP, http://dblp.uni-trier.de},
	Date-Modified = {2013-01-23 16:09:53 +0000},
	Journal = {CoRR},
	Title = {Reify Your Collection Queries for Modularity and Speed!},
	Url = {http://arxiv.org/abs/1210.6284},
	Volume = {abs/1210.6284},
	Year = {2012},
	Bdsk-Url-1 = {http://arxiv.org/abs/1210.6284}}

@inproceedings{Stucki18Truly,
	Acmid = {3241658},
	Address = {New York, NY, USA},
	Author = {Stucki, Nicolas and Giarrusso, Paolo G. and Odersky, Martin},
	Booktitle = {Proceedings of the 9th ACM SIGPLAN International Symposium on Scala},
	Doi = {10.1145/3241653.3241658},
	Isbn = {978-1-4503-5836-1},
	Keywords = {Scala, abstract types, extractors, interfaces, pattern matching},
	Location = {St. Louis, MO, USA},
	Numpages = {5},
	Pages = {56--60},
	Publisher = {ACM},
	Series = {Scala 2018},
	Title = {Truly Abstract Interfaces for Algebraic Data Types: The Extractor Typing Problem},
	Url = {http://doi.acm.org/10.1145/3241653.3241658},
	Year = {2018}}
