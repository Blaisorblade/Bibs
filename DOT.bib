@article{Rapoport2019Path,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1904.07298},
  primaryClass = {cs},
	title = {A Path To {{DOT}}: Formalizing Fully-Path-Dependent Types},
  url = {http://arxiv.org/abs/1904.07298},
  shorttitle = {A Path To {{DOT}}},
  abstract = {The Dependent Object Types (DOT) calculus aims to formalize the Scala programming language with a focus on path-dependent types \$-\$ types such as \$x.a\_1\textbackslash{}dots a\_n.T\$ that depend on the runtime value of a path \$x.a\_1\textbackslash{}dots a\_n\$ to an object. Unfortunately, existing formulations of DOT can model only types of the form \$x.A\$ which depend on variables rather than general paths. This restriction makes it impossible to model nested module dependencies. Nesting small components inside larger ones is a necessary ingredient of a modular, scalable language. DOT's variable restriction thus undermines its ability to fully formalize a variety of programming-language features including Scala's module system, family polymorphism, and covariant specialization. This paper presents the pDOT calculus, which generalizes DOT to support types that depend on paths of arbitrary length, as well as singleton types to track path equality. We show that naive approaches to add paths to DOT make it inherently unsound, and present necessary conditions for such a calculus to be sound. We discuss the key changes necessary to adapt the techniques of the DOT soundness proofs so that they can be applied to pDOT. Our paper comes with a Coq-mechanized type-safety proof of pDOT. With support for paths of arbitrary length, pDOT can realize DOT's full potential for formalizing Scala-like calculi.},
  urldate = {2019-04-17},
  date = {2019-04-15},
  year = {2019},
  keywords = {Computer Science - Programming Languages},
  author = {Rapoport, Marianna and Lhoták, Ondřej},
}

@inproceedings{Odersky2016Implementing,
  title = {Implementing Higher-Kinded Types in {{Dotty}}},
  isbn = {978-1-4503-4648-1},
  url = {http://dl.acm.org/citation.cfm?id=2998392.2998400},
  doi = {10.1145/2998392.2998400},
  eventtitle = {Proceedings of the 2016 7th {{ACM SIGPLAN Symposium}} on {{Scala}}},
  publisher = {{ACM}},
  urldate = {2019-08-12},
  date = {2016-10-30},
  year = {2016},
  pages = {51-60},
  author = {Odersky, Martin and Martres, Guillaume and Petrashko, Dmitry},
}

@article{Rapoport2017Simple,
	Abstract = {Dependent Object Types (DOT) is intended to be a core calculus for modelling Scala. Its distinguishing feature is abstract type members, fields in objects that hold types rather than values. Proving soundness of DOT has been surprisingly challenging, and existing proofs are complicated, and reason about multiple concepts at the same time (e.g. types, values, evaluation). To serve as a core calculus for Scala, DOT should be easy to experiment with and extend, and therefore its soundness proof needs to be easy to modify.   This paper presents a simple and modular proof strategy for reasoning in DOT. The strategy separates reasoning about types from other concerns. It is centred around a theorem that connects the full DOT type system to a restricted variant in which the challenges and paradoxes caused by abstract type members are eliminated. Almost all reasoning in the proof is done in the intuitive world of this restricted type system. Once we have the necessary results about types, we observe that the other aspects of DOT are mostly standard and can be incorporated into a soundness proof using familiar techniques known from other calculi.},
	Author = {Rapoport, Marianna and Kabir, Ifaz and He, Paul and Lhot\'ak, Ond{\v r}ej},
	Date-Added = {2018-11-29 13:45:45 +0100},
	Date-Modified = {2018-11-29 13:45:59 +0100},
	Doi = {10.1145/3133870},
	File = {/Users/pgiarrusso/Zotero/storage/UHEKZHVY/Rapoport-Kabir-He-Lhot{\'a}k - 2017 - A Simple Soundness Proof for Dependent Object Types.pdf;/Users/pgiarrusso/Zotero/storage/WNAKE2N8/Rapoport-Kabir-He-Lhot{\'a}k - 2017 - A Simple Soundness Proof for Dependent Object Types.pdf;/Users/pgiarrusso/Zotero/storage/B2NN7UZH/1706.html},
	Issn = {2475-1421},
	Journal = {Proc. ACM Program. Lang.},
	Keywords = {Computer Science - Programming Languages,type safety,_tablet,Scala,dependent object types,DOT calculus},
	Month = oct,
	Number = {OOPSLA},
	Pages = {46:1--46:27},
	Title = {A Simple Soundness Proof for Dependent Object Types},
	Volume = {1},
	Year = {2017}}

@inproceedings{Rompf2016type,
	Abstract = {Scala's type system unifies aspects of ML modules, object- oriented, and functional programming. The Dependent Object Types (DOT) family of calculi has been proposed as a new theoretic foundation for Scala and similar expressive languages. Unfortunately, type soundness has only been established for restricted subsets of DOT. In fact, it has been shown that important Scala features such as type refinement or a subtyping relation with lattice structure break at least one key metatheoretic property such as environment narrowing or invertible subtyping transitivity, which are usually required for a type soundness proof. The main contribution of this paper is to demonstrate how, perhaps surprisingly, even though these properties are lost in their full generality, a rich DOT calculus that includes recursive type refinement and a subtyping lattice with intersection types can still be proved sound. The key insight is that subtyping transitivity only needs to be invertible in code paths executed at runtime, with contexts consisting entirely of valid runtime objects, whereas inconsistent subtyping contexts can be permitted for code that is never executed.},
	Address = {New York, NY, USA},
	Author = {Rompf, Tiark and Amin, Nada},
	Booktitle = {Proceedings of the 2016 {{ACM SIGPLAN International Conference}} on {{Object}}-{{Oriented Programming}}, {{Systems}}, {{Languages}}, and {{Applications}}},
	Date-Added = {2017-11-16 22:06:36 +0000},
	Date-Modified = {2017-11-16 22:06:36 +0000},
	Doi = {10.1145/2983990.2984008},
	File = {Rompf_Amin - 2016 - Type Soundness for Dependent Object Types (DOT).pdf:/Users/pgiarrusso/Zotero/storage/SJ7HCPXJ/Rompf_Amin - 2016 - Type Soundness for Dependent Object Types (DOT).pdf:application/pdf},
	Isbn = {978-1-4503-4444-9},
	Keywords = {dependent object types,Scala,_tablet,DOT,soundness},
	Pages = {624--641},
	Publisher = {{ACM}},
	Series = {OOPSLA 2016},
	Timestamp = {2016-11-01T13:07:50Z},
	Title = {Type Soundness for Dependent Object Types ({{DOT}})},
	Urldate = {2016-11-01},
	Year = {2016},
	Bdsk-Url-1 = {http://dx.doi.org/10.1145/2983990.2984008}}

@article{Rapoport2017simpleold,
	Abstract = {Dependent Object Types (DOT) is intended to be a core calculus for modelling Scala. Its distinguishing feature is abstract type members, fields in objects that hold types rather than values. Proving soundness of DOT has been surprisingly challenging, and existing proofs are complicated, and reason about multiple concepts at the same time (e.g. types, values, evaluation). To serve as a core calculus for Scala, DOT should be easy to experiment with and extend, and therefore its soundness proof needs to be easy to modify. This paper presents a simple and modular proof strategy for reasoning in DOT. The strategy separates reasoning about types from other concerns. It is centred around a theorem that connects the full DOT type system to a restricted variant in which the challenges and paradoxes caused by abstract type members are eliminated. Almost all reasoning in the proof is done in the intuitive world of this restricted type system. Once we have the necessary results about types, we observe that the other aspects of DOT are mostly standard and can be incorporated into a soundness proof using familiar techniques known from other calculi. Our paper comes with a machine-verified version of the proof in Coq.},
	Archiveprefix = {arXiv},
	Author = {Rapoport, Marianna and Kabir, Ifaz and He, Paul and Lhot{\'a}k, Ond{\v r}ej},
	Date-Added = {2017-11-14 22:33:37 +0000},
	Date-Modified = {2018-11-29 13:45:53 +0100},
	Eprint = {1706.03814},
	Eprinttype = {arxiv},
	File = {Rapoport et al - 2017 - A Simple Soundness Proof for Dependent Object Types.pdf:/Users/pgiarrusso/Zotero/storage/WNAKE2N8/Rapoport et al - 2017 - A Simple Soundness Proof for Dependent Object Types.pdf:application/pdf;arXiv.org Snapshot:/Users/pgiarrusso/Zotero/storage/B2NN7UZH/1706.html:text/html},
	Journal = {arXiv:1706.03814 [cs]},
	Keywords = {Computer Science - Programming Languages,_tablet},
	Month = jun,
	Primaryclass = {cs},
	Timestamp = {2017-09-11T13:44:07Z},
	Title = {A {{Simple Soundness Proof}} for {{Dependent Object Types}}},
	Year = {2017}}

@article{Rapoport2016mutable,
	Abstract = {The Dependent Object Types (DOT) calculus aims to model the essence of Scala, with a focus on abstract type members, path-dependent types, and subtyping. Other Scala features could be defined by translation to DOT. Mutation is a fundamental feature of Scala currently missing in DOT. Mutation in DOT is needed not only to model effectful computation and mutation in Scala programs, but even to precisely specify how Scala initializes immutable variables and fields (vals). We present an extension to DOT that adds typed mutable reference cells. We have proven the extension sound with a mechanized proof in Coq. We present the key features of our extended calculus and its soundness proof, and discuss the challenges that we encountered in our search for a sound design and the alternative solutions that we considered.},
	Archiveprefix = {arXiv},
	Author = {Rapoport, Marianna and Lhot{\'a}k, Ond{\v r}ej},
	Date-Added = {2017-11-14 22:33:37 +0000},
	Date-Modified = {2017-11-14 22:33:37 +0000},
	Eprint = {1611.07610},
	Eprinttype = {arxiv},
	File = {Rapoport_Lhot{\'a}k - 2016 - Mutable WadlerFest DOT.pdf:/Users/pgiarrusso/Zotero/storage/ZMG67T43/Rapoport_Lhot{\'a}k - 2016 - Mutable WadlerFest DOT.pdf:application/pdf;arXiv.org Snapshot:/Users/pgiarrusso/Zotero/storage/44R5R43B/1611.html:text/html},
	Journal = {arXiv:1611.07610 [cs]},
	Keywords = {Computer Science - Programming Languages,_tablet},
	Month = nov,
	Primaryclass = {cs},
	Timestamp = {2017-01-06T18:48:31Z},
	Title = {Mutable {{WadlerFest DOT}}},
	Urldate = {2017-01-06},
	Year = {2016}}

@inproceedings{Wang2017strong,
	Address = {Dagstuhl, Germany},
	Author = {Wang, Fei and Rompf, Tiark},
	Booktitle = {31st {{European Conference}} on {{Object}}-{{Oriented Programming}} ({{ECOOP}} 2017)},
	Date-Added = {2017-09-26 01:27:19 +0000},
	Date-Modified = {2017-09-26 01:27:19 +0000},
	Doi = {10.4230/LIPIcs.ECOOP.2017.27},
	Editor = {M{\"u}ller, Peter},
	File = {Wang_Rompf - 2017 - Towards Strong Normalization for Dependent Object Types (DOT).pdf:/Users/pgiarrusso/Library/Application Support/Zotero/Profiles/0lm7uqnz.default/zotero/storage/TQ28KV6T/Wang_Rompf - 2017 - Towards Strong Normalization for Dependent Object Types (DOT).pdf:application/pdf;Snapshot:/Users/pgiarrusso/Library/Application Support/Zotero/Profiles/0lm7uqnz.default/zotero/storage/JF5STNRB/7276.html:text/html},
	Isbn = {978-3-95977-035-4},
	Keywords = {DOT,logical relations,recursive types,Scala,Strong Normalization},
	Pages = {27:1--27:25},
	Publisher = {{Schloss Dagstuhl\textendash{}Leibniz-Zentrum fuer Informatik}},
	Series = {Leibniz International Proceedings in Informatics (LIPIcs)},
	Timestamp = {2017-09-25T23:29:39Z},
	Title = {Towards Strong Normalization for Dependent Object Types ({DOT})},
	Volume = {74},
	Year = {2017},
	Bdsk-Url-1 = {http://dx.doi.org/10.4230/LIPIcs.ECOOP.2017.27}}

@inproceedings{Amin2017Type,
	Acmid = {3009866},
	Address = {New York, NY, USA},
	Author = {Amin, Nada and Rompf, Tiark},
	Booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
	Date-Added = {2017-01-18 14:00:16 +0000},
	Date-Modified = {2017-01-18 14:00:18 +0000},
	Doi = {10.1145/3009837.3009866},
	Isbn = {978-1-4503-4660-3},
	Keywords = {DOT, Definitional interpreters, Scala, dependent object types, type soundness},
	Location = {Paris, France},
	Numpages = {14},
	Pages = {666--679},
	Publisher = {ACM},
	Series = {POPL 2017},
	Title = {Type Soundness Proofs with Definitional Interpreters},
	Url = {http://doi.acm.org/10.1145/3009837.3009866},
	Year = {2017},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/3009837.3009866},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/3009837.3009866}}

@inproceedings{Amin2012Dependent,
	Abstract = {We propose a new type-theoretic foundation of Scala and
                 languages like it: the Dependent Object Types (DOT)
                 calculus. DOT models Scala's path-dependent types,
                 abstract type members and its mixture of nominal and
                 structural typing through the use of refinement types. The
                 core formalism makes no attempt to model inheritance and
                 mixin composition. DOT normalizes Scala's type system by
                 unifying the constructs for type members and by providing
                 classical intersection and union types which simplify
                 greatest lower bound and least upper bound computations.
                 In this paper, we present the DOT calculus, both formally
                 and informally. We also discuss our work-in-progress to
                 prove typesafety of the calculus.},
	Affiliation = {EPFL},
	Author = {Amin, Nada and Moors, Adriaan and Odersky, Martin},
	Booktitle = {19{t}h {I}nternational {W}orkshop on {F}oundations of {O}bject-{O}riented {L}anguages},
	Date-Added = {2013-01-23 18:13:15 +0000},
	Date-Modified = {2013-01-23 18:13:17 +0000},
	Details = {http://infoscience.epfl.ch/record/183030},
	Documenturl = {http://infoscience.epfl.ch/record/183030/files/fool.pdf},
	Keywords = {calculus; objects; dependent types},
	Location = {Tucson, Arizona, USA},
	Oai-Id = {oai:infoscience.epfl.ch:183030},
	Oai-Set = {conf},
	Review = {REVIEWED},
	Status = {PUBLISHED},
	Submitter = {164625},
	Title = {Dependent {O}bject {T}ypes},
	Unit = {LAMP},
	Url = {https://github.com/namin/dot},
	Year = 2012,
	Bdsk-Url-1 = {https://github.com/namin/dot}}

@phdthesis{Amin2016Dependent,
  location = {{Lausanne, Switzerland}},
  title = {Dependent Object Types},
  url = {https://infoscience.epfl.ch/record/223518},
  doi = {10.5075/epfl-thesis-7156, urn:nbn:ch:bel-epfl-thesis7156-6},
  institution = {{EPFL}},
  urldate = {2017-05-23},
  year = {2016},
  author = {Amin, Nada},
}

@inproceedings{Schafer2015Autosubst,
  langid = {english},
  title = {Autosubst: {{Reasoning}} with de {{Bruijn Terms}} and {{Parallel Substitutions}}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-22102-1_24},
  doi = {10.1007/978-3-319-22102-1_24},
  shorttitle = {Autosubst},
  abstract = {Reasoning about syntax with binders plays an essential role in the formalization of the metatheory of programming languages. While the intricacies of binders can be ignored in paper proofs, formalizations involving binders tend to be heavyweight. We present a discipline for syntax with binders based on de Bruijn terms and parallel substitutions, with a decision procedure covering all assumption-free equational substitution lemmas. The approach is implemented in the Coq library Autosubst, which additionally derives substitution operations and proofs of substitution lemmas for custom term types. We demonstrate the effectiveness of the approach with several case studies, including part A of the POPLmark challenge.},
  eventtitle = {International {{Conference}} on {{Interactive Theorem Proving}}},
  booktitle = {Interactive {{Theorem Proving}}},
  publisher = {{Springer, Cham}},
  urldate = {2017-06-24},
  date = {2015-08-24},
  year = {2015},
  pages = {359-374},
  author = {Schäfer, Steven and Tebbi, Tobias and Smolka, Gert},
}

@article{Hu2019Undecidability,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1908.05294},
  primaryClass = {cs},
  title = {Undecidability of ${D}_{<:}$ and its Decidable Fragments},
  shorttitle = {Undecidability of ${D}_{<:}$},
  abstract = {Dependent Object Types (DOT) is a calculus with path dependent types, intersection types, and object self-references, which serves as the core calculus of Scala 3. Although the calculus has been proven sound, it remains open whether type checking in DOT is decidable. In this paper, we establish undecidability proofs of type checking and subtyping of $D_{<:}$, a syntactic subset of DOT. It turns out that even for $D_{<:}$, undecidability is surprisingly difficult to show, as evidenced by counterexamples for past attempts. To prove undecidability, we discover an equivalent definition of the $D_{<:}$ subtyping rules in normal form. Besides being easier to reason about, this definition makes the phenomenon of bad bounds explicit as a single inference rule. After removing this rule, we discover two decidable fragments of $D_{<:}$ subtyping and identify algorithms to decide them. We prove soundness and completeness of the algorithms with respect to the fragments, and we prove that the algorithms terminate. Our proofs are mechanized in a combination of Coq and Agda.},
  journal = {arXiv:1908.05294 [cs]},
  author = {Hu, Jason and Lhot{\'a}k, Ond{\v r}ej},
  month = aug,
  year = {2019},
  keywords = {Computer Science - Programming Languages},
}

@incollection{Brandt1997coinductive,
  series = {Lecture Notes in Computer Science},
  title = {Coinductive Axiomatization of Recursive Type Equality and Subtyping},
  copyright = {\textcopyright{}1997 Springer-Verlag},
  isbn = {978-3-540-62688-6 978-3-540-68438-1},
  abstract = {We present new sound and complete axiomatizations of type equality and subtype inequality for a first-order type language with regular recursive types. The rules are motivated by coinductive characterizations of type containment and type equality via simulation and bisimulation, respectively. The main novelty of the axiomatization is the fixpoint rule (or coinduction principle), which has the form where P is either a type equality {$\tau$}={$\tau{'}$} or type containment {$\tau\leq\tau{'}$}. We define what it means for a proof (formal derivation) to be formally contractive and show that the fixpoint rule is sound if the proof of the premise A, P {$\vdash$} P is contractive. (A proof of A, P {$\vdash$} P using the assumption axiom is, of course, not contractive.) The fixpoint rule thus allows us to capture a coinductive relation in the fundamentally inductive framework of inference systems. The new axiomatizations are ``leaner'' than previous axiomatizations, particularly so for type containment since no separate axiomatization of type equality is required, as in Amadio and Cardelli's axiomatization. They give rise to a natural operational interpretation of proofs as coercions. In particular, the fixpoint rule corresponds to definition by recursion. Finally, the axiomatization is closely related to (known) efficient algorithms for deciding type equality and type containment. These can be modified to not only decide type equality and type containment, but also construct proofs in our axiomatizations efficiently. In connection with the operational interpretation of proofs as coercions this gives efficient (O(n 2) time) algorithms for constructing efficient coercions from a type to any of its supertypes or isomorphic types.},
  language = {en},
  number = {1210},
  booktitle = {Typed Lambda Calculi and Applications},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Brandt, Michael and Henglein, Fritz},
  editor = {de Groote, Philippe and Hindley, J. Roger},
  year = {1997},
  keywords = {Logics and Meanings of Programs,Mathematical Logic and Formal Languages,Mathematical Logic and Foundations,Programming Techniques},
  pages = {63-81}
}

@article{Brandt1998coinductive,
  title = {Coinductive Axiomatization of Recursive Type Equality and Subtyping},
  volume = {33},
  issn = {0169-2968},
  abstract = {We present new sound and complete axiomatizations of type equality and subtype inequality for a first-order type language with regular recursive types. The rules are motivated by coinductive characterizations of type containment and type equality via simulation and bisimulation, respectively. The main novelty of the axiomatization is the fixpoint rule (or coinduction principle). It states that from A,P \$\$\textbackslash{}vdash\$\$ P one may deduce A \$\$\textbackslash{}vdash\$\$ P, where P is either a type equality {$\tau$} = {$\tau$}' or type containment {$\tau$} {$\leq$} {$\tau$}' and the proof of the premise must be contractive in a sense we define in this paper. In particular, a proof of A, P \$\$\textbackslash{}vdash\$\$ P using the assumption axiom is not contractive. The fixpoint rule embodies a finitary coinduction principle and thus allows us to capture a coinductive relation in the fundamentally inductive framework of inference systems. The new axiomatizations are more concise than previous axiomatizations, particularly so for type containment since no separate axiomatization of type equality is required, as in Amadio and Cardelli's axiomatization. They give rise to a natural operational interpretation of proofs as coercions. In particular, the fixpoint rule corresponds to definition by recursion. Finally, the axiomatization is closely related to (known) efficient algorithms for deciding type equality and type containment. These can be modified to not only decide type equality and type containment, but also construct proofs in our axiomatizations efficiently. In connection with the operational interpretation of proofs as coercions this gives efficient (O(n 2) time) algorithms for constructing efficient coercions from a type to any of its supertypes or isomorphic types. More generally, we show how adding the fixpoint rule makes it possible to characterize inductively a set that is coinductively defined as the kernel (greatest fixed point) of an inference system.},
  number = {4},
  journal = {Fundam. Inf.},
  author = {Brandt, Michael and Henglein, Fritz},
  month = dec,
  year = {1998},
  keywords = {axiomatization,coercion,coinduction,fixpoint,inference rule,inference system,operational interpretation,recursive type,subtyping,type equality},
  pages = {309--338}
}

@inproceedings{Kabir2018kDOT,
  address = {{New York, NY, USA}},
  series = {Scala 2018},
  title = {{{kDOT}}: {{Scaling DOT}} with Mutation and Constructors},
  isbn = {978-1-4503-5836-1},
  shorttitle = {{$K$}dot},
  abstract = {Scala unifies concepts from object and module systems by allowing for objects with type members which are referenced via path-dependent types. The Dependent Object Types (DOT) calculus of Amin et al. models only this core part of Scala, but does not have many fundamental features of Scala such as strict and mutable fields. Since the most commonly used field types in Scala are strict,the correspondence between DOT and Scala is too weak for us to meaningfully prove static analyses safe for Scala by proving them safe for DOT.  A DOT calculus that can support strict and mutable fields together with constructors that do field initialization would be more suitable for analysis of Scala. Toward this goal, we present {$\kappa$}DOT, an extension of DOT that supports constructors and field mutation and can emulate the different types of fields in Scala. We have proven {$\kappa$}DOT sound through a mechanized proof in Coq. We present the key features of {$\kappa$}DOT and its operational semantics and discuss work-in-progress toward making {$\kappa$}DOT fully strict.},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Symposium}} on {{Scala}}},
  publisher = {{ACM}},
  doi = {10.1145/3241653.3241659},
  author = {Kabir, Ifaz and Lhot{\'a}k, Ond{\v r}ej},
  year = {2018},
  keywords = {type safety,dependent object types,mutation},
  pages = {40--50}
}

@inproceedings{Jung2016Higherorder,
  address = {{New York, NY, USA}},
  series = {{{ICFP}} 2016},
  title = {Higher-Order Ghost State},
  isbn = {978-1-4503-4219-3},
  abstract = {The development of concurrent separation logic (CSL) has sparked a long line of work on modular verification of sophisticated concurrent programs. Two of the most important features supported by several existing extensions to CSL are higher-order quantification and custom ghost state. However, none of the logics that support both of these features reap the full potential of their combination. In particular, none of them provide general support for a feature we dub "higher-order ghost state": the ability to store arbitrary higher-order separation-logic predicates in ghost variables.   In this paper, we propose higher-order ghost state as a interesting and useful extension to CSL, which we formalize in the framework of Jung et al.'s recently developed Iris logic. To justify its soundness, we develop a novel algebraic structure called CMRAs ("cameras"), which can be thought of as "step-indexed partial commutative monoids". Finally, we show that Iris proofs utilizing higher-order ghost state can be effectively formalized in Coq, and discuss the challenges we faced in formalizing them.},
  booktitle = {Proceedings of the 21st {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  doi = {10.1145/2951913.2951943},
  author = {Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
  year = {2016},
  keywords = {Separation logic,compositional verification,fine-grained concurrency,higher- order logic,interactive theorem proving},
  pages = {256--269}
}

@inproceedings{Crary2017Modules,
  address = {{New York, NY, USA}},
  series = {{{POPL}} 2017},
  title = {Modules, Abstraction, and Parametric Polymorphism},
  isbn = {978-1-4503-4660-3},
  abstract = {Reynolds's Abstraction theorem forms the mathematical foundation for data abstraction. His setting was the polymorphic lambda calculus. Today, many modern languages, such as the ML family, employ rich module systems designed to give more expressive support for data abstraction than the polymorphic lambda calculus, but analogues of the Abstraction theorem for such module systems have lagged far behind.   We give an account of the Abstraction theorem for a modern module calculus supporting generative and applicative functors, higher-order functors, sealing, and translucent signatures. The main issues to be overcome are: (1) the fact that modules combine both types and terms, so they must be treated as both simultaneously, (2) the effect discipline that models the distinction between transparent and opaque modules, and (3) a very rich language of type constructors supporting singleton kinds. We define logical equivalence for modules and show that it coincides with contextual equivalence. This substantiates the folk theorem that modules are good for data abstraction. All our proofs are formalized in Coq.},
  booktitle = {Proceedings of the 44th {{ACM SIGPLAN Symposium}} on {{Principles}} of {{Programming Languages}}},
  publisher = {{ACM}},
  doi = {10.1145/3009837.3009892},
  author = {Crary, Karl},
  year = {2017},
  keywords = {logical relations,modules,parametricity,Abstraction},
  pages = {100--113}
}

@inproceedings{Harper1994typetheoretic,
  address = {{New York, NY, USA}},
  series = {{{POPL}} '94},
  title = {A Type-Theoretic Approach to Higher-Order Modules with Sharing},
  isbn = {978-0-89791-636-3},
  abstract = {The design of a module system for constructing and maintaining large programs is a difficult task that raises a number of theoretical and practical issues. A fundamental issue is the management of the flow of information between program units at compile time via the notion of an interface. Experience has shown that fully opaque interfaces are awkward to use in practice since too much information is hidden, and that fully transparent interfaces lead to excessive interdependencies, creating problems for maintenance and separate compilation. The ``sharing'' specifications of Standard ML address this issue by allowing the programmer to specify equational relationships between types in separated modules, but are not expressive enough to allow the programmer complete control over the propagation of type information between modules.
These problems are addressed from a type-theoretic viewpoint by considering a calculus based on Girard's system F\&ohgr;. The calculus differs form those considered in previous studies by relying exclusively on a new form of weak sum type to propagate information at compile-time, in contrast to approaches based on strong sums which rely on substitution. The new form of sum type allows for the specification of equational, as well as type and kind, information in interfaces. This provides complete control over the propagation of compile-time information between program units and is sufficient to encode in a straightforward way most users of type sharing specifications in Standard ML.
Modules are treated as ``first-class'' citizens, and therefore the system supports higher-order modules and some object-oriented programming idioms; the language may be easily restricted to ``second-class'' modules found in ML-like languages.},
  booktitle = {Proceedings of the 21st {{ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  publisher = {{ACM}},
  doi = {10.1145/174675.176927},
  author = {Harper, Robert and Lillibridge, Mark},
  year = {1994},
  pages = {123--137}
}

@article{Rossberg2013mixin,
  title = {Mixin' up the {{ML}} Module System},
  volume = {35},
  issn = {0164-0925},
  abstract = {ML modules provide hierarchical namespace management, as well as fine-grained control over the propagation of type information, but they do not allow modules to be broken up into mutually recursive, separately compilable components. Mixin modules facilitate recursive linking of separately compiled components, but they are not hierarchically composable and typically do not support type abstraction. We synthesize the complementary advantages of these two mechanisms in a novel module system design we call MixML. A MixML module is like an ML structure in which some of the components are specified but not defined. In other words, it unifies the ML structure and signature languages into one. MixML seamlessly integrates hierarchical composition, translucent ML-style data abstraction, and mixin-style recursive linking. Moreover, the design of MixML is clean and minimalist; it emphasizes how all the salient, semantically interesting features of the ML module system (and several proposed extensions to it) can be understood simply as stylized uses of a small set of orthogonal underlying constructs, with mixin composition playing a central role. We provide a declarative type system for MixML, including two important extensions: higher-order modules, and modules as first-class values. We also present a sound and complete, three-pass type-checking algorithm for this system. The operational semantics of MixML is defined by an elaboration translation into an internal core language called LTG---namely, a polymorphic lambda calculus with single-assignment references and recursive type generativity---which employs a linear type and kind system to track definedness of term and type imports.},
  number = {1},
  journal = {ACM Trans. Program. Lang. Syst.},
  doi = {10.1145/2450136.2450137},
  author = {Rossberg, Andreas and Dreyer, Derek},
  month = apr,
  year = {2013},
  keywords = {abstract data types,hierarchical composability,mixin modules,ML modules,recursive modules,type systems},
  pages = {2:1--2:84}
}

@article{Rossberg20181ML,
  title = {{{1ML}} \textemdash{} {{Core}} and Modules United},
  volume = {28},
  issn = {0956-7968, 1469-7653},
  abstract = {ML is two languages in one: there is the core, with types and expressions, and there are modules, with signatures, structures, and functors. Modules form a separate, higher-order functional language on top of the core. There are both practical and technical reasons for this stratification; yet, it creates substantial duplication in syntax and semantics, and it imposes seemingly unnecessary limits on expressiveness because it makes modules second-class citizens of the language. For example, selecting one among several possible modules implementing a given interface cannot be made a dynamic decision. Language extensions allowing modules to be packaged up as first-class values have been proposed and implemented in different variations. However, they remedy expressiveness only to some extent and tend to be even more syntactically heavyweight than using second-class modules alone. We propose a redesign of ML in which modules are truly first-class values, and core and module layers are unified into one language. In this ``1ML'', functions, functors, and even type constructors are one and the same construct; likewise, no distinction is needed between structures, records, or tuples. Or viewed the other way round, everything is just (``a mode of use of'') modules. Yet, 1ML does not require dependent types: its type structure is expressible in terms of plain System F{$\omega$}, with a minor variation of our F-ing modules approach. We introduce both an explicitly typed version of 1ML and an extension with Damas\textendash{}Milner-style implicit quantification. Type inference for this language is not complete, but, we argue, not substantially worse than for Standard ML.},
  language = {en},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796818000205},
  author = {Rossberg, Andreas},
  year = {2018/ed}
}

@inproceedings{Nieto2017Algorithmic,
  address = {{New York, NY, USA}},
  series = {{{SCALA}} 2017},
  title = {Towards {{Algorithmic Typing}} for {{DOT}} ({{Short Paper}})},
  isbn = {978-1-4503-5529-2},
  abstract = {The Dependent Object Types (DOT) calculus formalizes key features of Scala. The D{$<$}: calculus is the core of DOT. To date, presentations of D{$<$}: have used declarative, as opposed to algorithmic, typing and subtyping rules. Unfortunately, algorithmic typing for full D{$<$}: is known to be an undecidable problem. We explore the design space for a restricted version of D{$<$}: that has decidable typechecking. Even in this simplified D{$<$}:, algorithmic typing and subtyping are tricky, due to the {\^a}bad bounds{\^a} problem. The Scala compiler bypasses bad bounds at the cost of a loss in expressiveness in its type system. Based on the approach taken in the Scala compiler, we present the Step Typing and Step Subtyping relations for D{$<$}:. These relations are sound and decidable. They are not complete with respect to the original D{$<$}: typing rules.},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Symposium}} on {{Scala}}},
  publisher = {{ACM}},
  doi = {10.1145/3136000.3136003},
  author = {Nieto, Abel},
  year = {2017},
  keywords = {Scala,dependent object types,algorithmic typing,DOT calculus},
  pages = {2--7},
  note = {00000}
}

@misc{Giarrusso2019distribute,
  title = {Can we prove that type constructors are ``distributive''?},
  author = {Paolo G. Giarrusso},
  year = {2019},
  note = {Github issue, \url{https://github.com/lampepfl/dotty-feature-requests/issues/51}},
}

@misc{Stucki2016higher,
  title = {{DOT} with higher-kinded types -- A sketch},
  author = {Sandro Stucki},
  year = {2016},
  note = {Github discussion, \url{https://gist.github.com/sstucki/3fa46d2c4ce6f54dc61c3d33fc898098}},
}

@inproceedings{Schafer2015Autosubst,
  langid = {english},
  title = {Autosubst: {{Reasoning}} with de {{Bruijn Terms}} and {{Parallel Substitutions}}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-22102-1_24},
  doi = {10.1007/978-3-319-22102-1_24},
  shorttitle = {Autosubst},
  abstract = {Reasoning about syntax with binders plays an essential role in the formalization of the metatheory of programming languages. While the intricacies of binders can be ignored in paper proofs, formalizations involving binders tend to be heavyweight. We present a discipline for syntax with binders based on de Bruijn terms and parallel substitutions, with a decision procedure covering all assumption-free equational substitution lemmas. The approach is implemented in the Coq library Autosubst, which additionally derives substitution operations and proofs of substitution lemmas for custom term types. We demonstrate the effectiveness of the approach with several case studies, including part A of the POPLmark challenge.},
  eventtitle = {International {{Conference}} on {{Interactive Theorem Proving}}},
  booktitle = {Interactive {{Theorem Proving}}},
  publisher = {{Springer, Cham}},
  urldate = {2017-06-24},
  date = {2015-08-24},
  year = {2015},
  pages = {359-374},
  author = {Schäfer, Steven and Tebbi, Tobias and Smolka, Gert},
}

@inproceedings{Stark2019Autosubst,
  address = {{New York, NY, USA}},
  series = {{{CPP}} 2019},
  title = {Autosubst 2: {{Reasoning}} with {{Multi}}-Sorted {{De Bruijn Terms}} and {{Vector Substitutions}}},
  isbn = {978-1-4503-6222-1},
  shorttitle = {Autosubst 2},
  abstract = {Formalising metatheory in the Coq proof assistant is tedious as reasoning with binders without native support requires a lot of uninteresting technicalities. To relieve users from so-produced boilerplate, the Autosubst framework automates working with de Bruijn terms: For each annotated inductive type, Autosubst generates a corresponding instantiation operation for parallel substitutions and a decision procedure for assumption-free substitution lemmas. However, Autosubst is implemented in Ltac, Coq's tactic language, and thus suffers from Ltac's limitations. In particular, Autosubst is restricted to Coq and unscoped, non-mutual inductive types with a single sort of variables. In this paper, we present a new version of Autosubst that overcomes these restrictions. Autosubst 2 is an external code generator, which translates second-order HOAS specifications into potentially mutual inductive term sorts. We extend the equational theory of Autosubst to the case of mutual inductive sorts by combining the application of multiple parallel substitutions into exactly one instantiation operation for each sort, i.e. we parallelise substitutions to vector substitutions. The resulting equational theory is both simpler and more expressive than that of the original Autosubst framework and allows us to present an even more elegant proof of part A of the POPLMark challenge.},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  publisher = {{ACM}},
  doi = {10.1145/3293880.3294101},
  author = {Stark, Kathrin and Sch{\"a}fer, Steven and Kaiser, Jonas},
  year = {2019},
  keywords = {de Bruijn repersentation,multi-sorted terms,parallel substiutions,sigma-calculus},
  pages = {166--180}
}

